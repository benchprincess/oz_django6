# Django 특강 with 덕배 2024-11-12


## . 으로 시작하는 파일
- . 으로 이름이 시작하는 파일이나 디렉터리는 "숨겨진 파일" or "숨겨진 디렉터리" 이다.
- 숨겨진 것들은 그냥 `ls` 로는 조회가 안되고, `ls -al` 로 조회할 수 있다.


## PEP?
- Python Enhancement Proposal
- PEP 는 규칙이 아니라 "제안"
- 진짜로 cpython 을 개발하는 파이썬 커미터들 포함, 파이썬 커뮤니티에서
    "어떻게 앞으로 개선할 것인가" 를 놓고 서로 제안하고, 승인하기도 하고, decline 하기도 합니다.
- 승인된 PEP 는 실제로 구현이 되서, 다음 파이썬 버전에 포함됩니다.
- e.g.) PEP 255 는 "제너레이터" 입니다. pep 255 에 의해서 제너레이터가 도입되었습니다.
- 공식문서 (python official document, PEP, django documentation) 를 가까이 하도록 합시다.

## Black
- code formatter, 코드 스타일을 맞춰준다.


## git commit 하기 전에 (중요)
- 자기가 뭘 커밋하는지 꼭, 커밋전에 한 번 더 확인하기
- 지우지 않은 print() 가 있는지 확인하세요~
    - print 는 IO 를 수반하기 때문에, (터미널에 출력해야되기 때문) 비싼 연산입니다.
    - 의도하지 않은 print 가 남아있지 않도록 합시다!

## git 과 pycharm project panel
- 흰색 파일: 수정되지 않은 파일
- 파란색 파일: 한 번이라도 commit 된 적이 있고, 현재 커밋되지 않은 변경사항이 있는 파일
- 초록색: git add 가 된 새로운 파일
- 빨간색: add 되지 않은 새로운 파일 (즉, git 에 추적이 안 되고 있음)


## pycharm git diff view 보는 방법
- 왼쪽이 과거 상태, 오른쪽이 현재 상태 (your version 이라고 표기가 되어 있습니다.)\
- 커맨드 + 화살표 아래 를 하면, diff view 에서 edit view 로 전환합니다.


## poetry 의 종속성 관리
- poetry add 를 실행할 때 `-D` 옵션을 주면, 종속성을 dev dependency 로 추가합니다.
- black 은 "실제 실행에는 필요가 없습니다." 오로지 "개발할떄만 필요합니다."
- 운영환경에서 실행할때에는 설치할 필요가 없고 오직 개발할 때에만 필요한 종속성을 dev dependency 에 추가합니다.

- caret(^) requirements
    - 하위 호환을 깨지 않는 범위에서, 가장 최신 버전을 사용하겠다. 라는 의미가 됩니다.
    - major 가 오르지 않는 범위 내에서

## kpoetry.loc 파일
- "정확히 어떤 버전을 설치해야 할지" 버전 정보가 lock 파일에 담겨있습니다.
- 프로젝트를 처음 클론받고 `poetry install --no-root` 를 할 때, 디폴트 동작은 lock 파일을 보고 설치합니다.
- lock 파일을 커밋해야합니다!!!!


## lock 파일의 content hash
- hash 를 쉽게 설명하면 -> 임의의 문자열을 입력으로 받아서 정해진 길이의 문자열을 반환하는 함수
    - 해쉬의 특징은 "결정적"이다. 입력 문자열이 똑같다면, 결과도 항상 똑같습니다. (랜덤성이 없다.)
    - 해쉬의 용도는 다양 (git commit 의 id 를 만드는 데에도 쓰이고, 비밀번호 암호화에도 쓰인다.)
    - lock 파일의 hash 는 "lock 파일이 변했느냐 변하지 않았느냐" 를 빠르게 판단하기 위해서 쓰입니다.
    - 과거에 저장해둔 hash 와 현재 lock 파일의 hash 가 다르다면 -> `poetry install`


## 하위 호환성
```python
## 라이브러리 코드
# 함수에도 타입이 있다.
def my_func() -> None:
    print()


## 클라이언트 코드 (사용자쪽 코드)
my_func(3)


# 하위호환을 깨는 변경 -> 업데이트를 했을때, 클라이언트에서 에러가 나는 경우
#    -> 업데이트했을 때 클라이언트도 적절히 수정해 주어야만 함.
# e.g.)
# 리턴하는 객체에서 멤버를 제외하는 경우
# 디폴트가 없는 인자를 추가하는 경우
# 기존에 받는 인자를 삭제하는 경우

# 하위호환을 지키는 변경 -> 업데이트를 해도 클라이언트 측에서는 수정할 필요가 없다.
# - 리턴하는 객체에 멤버를 추가하는 경우 (타입 자체는 안 바뀜)
# - 디폴트 값이 있는 입력을 추가하는 경우

```

## Mypy
- 다른걸 다 안써도 mypy 하나만큼은 써야 합니다! 제일 중요합니다.
- 그마만큼 mypy 를 지키는게 제일 어렵습니다. 하지만 제일 효과가 좋습니다. 장애를 예방하는 데 효과가 좋습니다.

- 미션 크리티컬? -> 장애나면 진짜 큰일나는 경우



## holleywood 패턴
```python

# 부모가 자식을 호출?
# 부모의 method 가 자식이 override 한 메소드를 호출합니다.

# holleywood 패턴
# 높은 사람 (회사, 영화 제작자 측이) -> 낮은 사람 (배우)
# 전체의 흐름을 부모가 완벽하게 제어한다는 보장이 됩니다.
# 구현 세부사항 (상대적으로 작은 private method)
# 예측 가능성이 높아진다!

class Parent:

    def _my_inner_func(self):
        """
        비어있는 private method
        """
        pass

    def my_func(self):
        """
        부모의 public method 가 비어있는 자신의 private method 를 호출한다.
        """
        print("부모 public 호출")
        result = self._my_inner_func()


class Child(Parent):

    def _my_inner_func(self):
        print("inner func 를 자식이 구현했어")


# 실행하면 뭐가 출력이 되나요?
Child().my_func()

```

## mypy 의 타입 추론.
- 변수 할당시에, 할당 연산자 오른쪽을 보고 mypy 는 타입을 추론합니다.
```python

def my_func() -> int:
    return 3

result = my_func()  # 이 경우, 함수의 리턴 타입이 int 기 때문에, 변수 result 의 타입은 int 일 것으로 유추할 수 있다.

```


## mypy strict
- strict 옵션이 켜졌을 때, collection 의 경우에, collection 내부에 어떤 타입이 들어가는지도 함께 명시해주어야 한다.



## type annotation 과 collection
```python
my_list: list[int | str] = [1, "1"]

my_dict: dict[str, int] = {"a": 1}

my_tuple: tuple[int, ...] = (
    1,
    3,
)

# Django 특강 with 덕배 2024-11-13

## tuple 자체는 immutable 하지만, tuple 안의 요소는 mutable 할 수 있다.

```python

class MyMutableClass:
    value: int

    def __init__(self, value: int):
        self.value = value


obj = MyMutableClass(3)


my_tuple = (obj, )

print(my_tuple[0].value)
my_tuple[0].value = 5
print(my_tuple[0].value)

```

## Continuous Integration



## 파일의 실행 권한
- 파일을 만들면 기본적으로 "실행 할 수 있는 권한" 이 없는 상태에서 생성됩니다.
- 어떻게하면 파일을 "실행할 수 있게" 만들까요?
    - `chmod +x <파일 이름>`


## PR 리뷰
- on push 로 CI 를 수행했다면, CI 수행 결과가 pull request 에서 보입니다.
- 수행 결과가 fail 인데 approve 하면 안 됩니다!
- pull request 를 만들고 나서, CI 가 성공했는지 꼭 확인하도록 합시다. CI 가 실패했다면 동료들끼리 서로 제보해줍시다.
- merge 이후에도 on push 트리거가 동작합니다. (머지 & push 가 일어났다고 생각하면 됩니다.)
- main 에 합치고 나서 main 에서 CI 가 터질 수 있습니다. -> 꼭 확인하기!
    - main 을 항상 깨끗하게 유지하려고 노력합시다!

- 깃허브 설정에서, approve 개수와, CI 성공여부를 체크해서, 조건을 충족하지 못하면 merge 가 안되도록 막을 수 있습니다.


## mysql 실행확인하기
- `lsof -i :3306` 포트 3306 에 어떤 프로세스가 실행되고 있는지 확인할 수 있습니다.


## 잘못된 브렌치에 커밋했을 때 대처방법
- 올바른 브렌치로 checkout 해서 돌아옵니다.
- 현재 Working Directory 의 수정 사항을 stash (혹은 pycharm 에 shelve 합니다.)
- 방금 했던 "잘못된 커밋" 을 cherry-pick 합니다. (깃 패널에서 커밋을 우클릭하면 cherry-pick 버튼이 보입니다.)
- 방금 stash (혹은 shelve 혹은 한글로 "보류") 했던 수정사항을 되돌립니다. (unshelve)

## 요구사항 분석
- 개발을 시작하기 전에 요구사항을 꼼꼼하게 분석하는 것이 중요합니다.



## audit column
- 직역하면 "감사" 컬럼 (thank you 아님)
    - 이 row 가 최초로 언제 생성되었는가, 언제 마지막 으로 수정되었으며, 누가 만들었고 누가 수정했는가
    - 혼자서 프로젝트 할때 -> 생성한 것도 나요, 수정한 것도 나다.
    - 여러명이서 개발 할때 -> (기록하지 않으면) 누가 손댔는지 알기 어려움
    - 사고가 났을때 책임을 물어야 할 때도 있음 -> 이때 감사 컬럼이 필요합니다.


## 마이그레이션을 만들고 나서 꼭 해야 하는일
- 이 마이그레이션 파일이 어떤 SQL 을 실제로 실행하는지 확인해야 합니다.


## primary key 는 big int 로 하자.
- 사용자가 생성할 수 있는 데이터는 그 pk 를 bigint 로 하는게 맞습니다. (대부분의 경우에 맞음)
    - auto increment
    - integer 의 max 는? 21 억
    - auto increment integer 에서 max 값에 도달하면 어떤 일이 일어날까요???? 0?
        -> insert 실패!!!!!!!!
    -> 주문 테이블이 어느 날 21억을 넘겼다!!!!!!
        = 피크 타임떄 10분만 주문이 안되도 억단위의 주문을 잃어버림...!
        - 대부분의 사용자는 기다리기보다는, 경쟁사 앱으로 넘어가는것을 선택합니다...!
    -> 전사 슬랙 에 공지가 뜹니다 "비상비상~~" 모든 (백엔드) 개발자는 하던 일을 멈추고 그 이슈를 봐야 함...!
    - 가장 빠르게 주문을 다시 받을 수 있게 하는 방법은...???

        -> 복사해서 새로 만든다. -> 30분은 걸림....?
        -> 주문테이블만 다 지운다. -> 돈이 오고 간 기록은 5년 이상을 보관해야 합니다.
            -> 백업은 보통 하루전 데이터 까지 백업이 되어 있습니다.

        -> 같은 스펙을 같고, 이름만 다른 테이블을 추가해서, 여기에 쌓는다.
            -> 방금 결제한 주문이 검색이 안됨?????
            -> 주문취소가 안되!!!!!!! (내 돈은????)
        -> 오늘 데이터만 옮긴다
            -> 여전히 "어제" 주문 밑 그 이전 주문을 찾을 수 없고 결제는 안되긴 하는데 대부분의 케이스는 커버 가능

        -> 강산
            ALTER TABLE -> 테이블 정의를 바꾼다. 타입의 크기를 int -> bigint 로 바꾼다.
            -> 당시에 버전이 굉장히 낮은 postgres 를 사용 -> alter table 해서 컬럼 타입을 바꾸는 순간 테이블 전체에 락이 걸림.
            -> 21 억건의 데이터에 대하여 전부 alter 컬럼을 수행 해야되며, 모든 row 의 int 의 사이즈를 2배로 늘려야 함
            -> 3 시간이 넘게 걸리는 작업 ^__^

        -> int MAX 21억, int MIN????? -21 억


## 오늘 배운 중요한 습관
- migration 수행하기 전에 실제 sql 을 꼭 확인하자.
- 코드를 실행하기 전에 "어떻게 실행될 것인지" 예측 해보고, 정말 예상대로 실행되었는지 확인하는 습관을 갖자.
- 공식문서를 가까이하고 주의깊게 읽자.


## 단축키
- 커맨드 + 옵션 + 화살표 왼쪽: 직전 커서로 돌아간다.
- 커맨드 + 7 : 스트럭쳐 뷰. 파일을 요약해서 보여줍니다.



## 스트럭쳐 뷰
- 스트럭쳐 뷰에서 클래스의 멤버중에 "회색" 으로 보이는 멤버는 "물려받은" 멤버다.


## auto now
- 공식문서를 보면, `Automatically set the field to now every time the object is saved` 라고 적혀 있습니다.
- 따라서 save() 를 호출할때만 auto_now 가 동작합니다.
- filter().update() 를 사용하면 auto_now 가 기능하지 않습니다.
- 또한, 마이그레이션 sql 을 보면 알 수 있듯, 이 동작은 데이터베이스가 아니라 django 에서 일어납니다.
    - 따라서, django 를 거치지 않고 row 를 직접 데이터베이스에 insert 한다면 auto_now 가 동작하지 않습니다.

# Django 특강 with 덕배 2024-11-14

## pre-commit
- 매 번 커밋하기 전에 black, isort, mypy, 단위테스트 등등등을 수행하도록 할 수 있다.
- https://pre-commit.com/
- 덕배가 잘 안쓰는 이유 -> 매 번 커밋할때마다 꼭 수행할 필요가 없는 경우도 있음
    - rebase 할 때마다 매 번 pre-commit 이 수행되는 문제도 있음 (불필요하고 시간도 오래걸립니다.)
- 덕배의 생각: PR 올리고 나서만 CI 가 성공하면 된다는 생각.


## bulk create
- 2 개 이상의 model 을 한번에 insert 하고 싶다면 `bulk_create()` 를 사용합니다.
    `User.objects.bulk_create([User(name="a"), User(name="b")])`
    - bulk_create 할떄 auto_now 동작하는지 가물가물...? 확인 필요

## 디버깅
- 오늘 수업에서 단 한 가지만 기억할 수 있다면 "디버깅" 을 기억하십시오!
- 김 포프: 나는 디버깅을 못하는 사람 중에서 개발을 잘하는 사람을 거의 본적이 없고,
    개발을 잘하는 사람 중에서 디버깅을 못하는 사람은 (아예) 본적이 없다.
- 중단점(break point): 프로그램을 멈출건데, 이 라인을 실행하기 직전에 멈출것이다.
- 디버그 패널에서 변수 내부를 볼 수 있습니다. 디버그 패널 오른쪽에 watch 가 있습니다. (지역변수 목록을 보여줍니다.)
- (프로그램을 멈춘 상태로) 뭐든지 뭔가를 실행해보고 싶다면? (expression)
- watch 화면에서 검색도 할 수 있습니다. 그냥 검색어를 타이핑 하면 됩니다.

### Evaluate Expression (표현식 평가)
- 중단점에 의해서 시간이 정지된 상태로, 무엇이든지 실행해 볼 수 있습니다.
- watch 패널에서 실행할 수도 있고, 디버그 패널에서 More 메뉴로 들어간 다음에 Evaluate Expression 을 선택할 수도 있습니다.


## 디버깅 중 실행흐름의 컨트롤
- Step over -> 한 줄 밑으로 실행합니다.
- Step Into -> 함수 내부로 들어갑니다.
- Resume (구버전에서는 Run to Cursor) -> 다음 중단점 까지 실행합니다.


## 디버깅이 중요한 이유
- 제 강의의 목적은 제가 없어도 여러분이 스스로 문제를 해결할 수 있도록 하는 것.
- 디버깅을 못하면, 원인을 못찾습니다. 반대로 디버깅을 할 수 있다면 문제의 원인을 찾을 수 있게 됩니다.
- 어느 지점부터 여러분의 예상과는 다르게 동작을 했는지, 디버깅을 사용하면 쉽게 알 수 있습니다. (중단점 찍고, 변수 내부 보고, 실행 흐름을 보면 됩니다.)


## Django Isolation (격리, 헬스에서는 고립)
- 쟝고는 테스트용 데이터베이스를 따로 만듭니다. (이 데이터베이스는 처음에 비어있습니다.)
- (트랜젝션을 안 배운 상태긴 하지만) 쟝고는 모든 테스트를 트랜젝션 안에서 수행합니다.
    - BEGIN 으로 시작
    - 끝낼때는 COMMIT(트랜젝션 내의 모든 변경을 영속화합니다.), ROLLBACK(트랜젝션 전체를 없던 것 처럼 만듭니다.) 둘 중 하나를 할 수 있습니다.
- 위 두가지에 의해서 테스트들이 "격리"된 상태에서 수행되게 됩니다.
- 테스트가 외부 데이터에 흔들리지(영향을 받지) 않게 됩니다.
- 디버깅을 비정상종료 할 경우 쟝고가 테스트 데이터베이스를 삭제하지 못합니다. 그 다음번에 테스트를 실행하면 "데이터베이스를 삭제하고 새로 만들어도 되나요?" 라고
    django 가 물어보는데, 이 때는 yes 하면 됩니다.


## 테스트 함수가 실패와 성공을 판가름 하는 방법
- 테스트 함수는 아무런 exception 이 발생하지 않고 종료되었을때 성공합니다.
- 반대로, 어떤 Exception 이든 exception 이 발생했다면 실패입니다.
- 검증을 하되, 검증 실패시 에러가 일어나도록 하고 싶다면 `assert` 를 사용합니다.
    e.g.) `assert 1 + 1 == 2`


## Working Directory (작업 폴더)
- 작업 폴더가 깨끗하다 -> 커밋할게 없다.
- 중요한 습관: 항상 개발을 시작할 때에는 작업 폴더를 깨끗하게 만든 후에, 전체 테스트가 전부 통과하는지 확인하고 -> 개발 시작합니다.


## 제품 코드, TDD
- 프로젝트 내의 코드를 제품 코드와, 테스트 코드로 나눕니다. 제품 코드 <--> 테스트 코드
- 교재의 do_like() 가 제품 코드입니다.
- Test Driven Development : 테스트 코드를 먼저 작성하고, 테스트가 실패하는 것을 확인하고, 그 다음에 제품 코드를 작성하고 테스트가 통과하는지 확인하는 개발 방식
    - 장점: 제품 코드를 먼저 작성하고 그 후에 테스트를 쓰면, 무의식적으로 "성공하는 테스트"만 짜게 됩니다.
    - 테스트 코드를 먼저 작성하면 위와 같은 방어기제가 동작하지 않기 때문에 더 견고하게 테스트 & 제품 코드를 짤 수 있다.
    - agile practice 중에 하나입니다. (애자일 실천방법)

## 디버그 복습
- 디버깅 단축키: 컨트롤 + 쉬프트 + D
- 디버그 시작하기 전에 중단점을 찍고 디버그를 시작해야 합니다.
(중단점이 하나도 없다면, 그냥 실행하는 것과 다름이 없습니다.)
(주의할 점: 디버그모드로 실행하면 프로그램은 더 느려집니다.)

## 실행 흐름의 컨트롤
- 한 줄 밑으로 실행: step over
- 함수 안으로 들어가려면: step into
- step into 에는 2가지가 있습니다.
- step into my code (라이브러리안으로 들어가지 않습니다.)
- step into 그냥 안으로 들어갑니다.
- 다음 중단점을 만날때까지 실행: resume program
(옛날 파이참: run to cursor)